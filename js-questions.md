 Document

Я могу предложить вам несколько вопросов, которые позволят вам определить уровень знаний собеседуемого в нативном JavaScript и React.

Легкие вопросы:
---------------

1.  ### Что выведется, если ввести в консоль следующее выражение:
    
    				0,5+0,5
            	
    
    Ответ будет 5
    
    В данном случае разработчик дожен заметить, что 0,5 - это не 0.5, а 0 затем оператор запятая, затем пять. В итоге эта надпись интерпритируется как 0,5,5. При записи нескольких примитивов, идущих через оператор запятую, в консоли выводится последий из них, то есть 5.
    
2.  ### Что выведется, если ввести в консоль следующее выражение:
    
    				let a = {key: 'value'}; a.toString()
            	
    
    Ответ будет
    
    				'[object Object]'
                
    
    В данном случае программист должен знать, что метод toString объекта возвращает не его содержимое, а вышеуказанную строку. Чтобы получить строкой ключи и значения массива, необходимо использовать JSON.parse()
    
3.  ### Что выведется, если ввести в консоль следующее выражение:
    
    				let a = 5; let a = a + 5; a
    			
    
    Ответом будет ошибка
    
    Здесь нужно помнить, что через let можно определить переменную только один раз, в отличае от определения через var.
    
4.  ### Что выведется, если ввести в консоль следующее выражение:
    
    				[1, 2, 3] + [4, 5, 6]
            	
    
    Ответом будет '1,2,34,5,6'
    
    При сложении массива с другим массивом, либо со строкой, складывается не сам массив, а результат действия его метода toString. Этот метод возвращает строкой все его аргументы, отделяя их запятой. В случае, когда массив пустой, этот метод возвращает пустую строку. В итоге наша первоначальная задача эквивалентна сложению двух строк:
    
    				'1,2,3' + '4,5,6'
            	
    
5.  ### Что выведется, если ввести в консоль следующее выражение:
    
    				'B' + 'a' +   + 'a' + 'a'
            	
    
    Ответом будет 'BaNaNa'
    
    Оператор +, стоящий перед строкой преобразует ее в NaN. Поэтому условие эквивалентно снедующему выражению:
    
    				'B' + 'a' + NaN + 'a'
            	
    
6.  ### Что выведется, если ввести в консоль следующее выражение:
    
    				!!false === !!'false'
            	
    
    Ответом будет false
    
    Здесь нужно помнить, что любая строка, кроме строки нулевой длинны возвращает true. В итоге получаем false === true, что выведет false
    

Средние вопросы:
----------------

1.  ### Перечислите способы как можно создать многострочный текст с переменной внутри:
    
    Ответ:
    
    				"строка \n\
    				строка " + variable
                
    
    es6 template:
    
    				`строка 
    				строка ${variable}`
                
    
    Для того что бы ваш текст перешел на следующую строку можно использовать специальный символ \\n. И для наглядности кода что бы компилятор не ругался также использовать \\ в конце строки, что бы можно было печатать его также многострочно. Второй вариант использовать es6 темплейты
    
2.  ### Что выведет в консоль и что за выражение находится после typeof?:
    
    				typeof /moz/gi;
            	
    
    правильный ответ: "object"
    
    То что это регулярное выражение кандидат должен определить легко, так же он должел рассказать что это регулярка для поиска повторений "moz" в строке. Причем должен знать значения флагов:
    
    g: поиск глобально, тоесть ответом будет массив включающий в себя все повторы
    
    i: игнорирование регистра при сопоставлении (заглавные буквы и маленькие ищет одинаково) например:
    
    				"11111moz111moz1111moz".match(/moz/gi)  // -> вернет ["moz", "moz", "moz"]
    				"11111moz111moz1111moz".match(/moz/g)  // -> вернет 1 повтор но с мета данными ["moz", index: 5, input: "11111moz111moz1111moz", groups: undefined]
    				
    
    вообще если кандидат сможет перечислить все пять флагов то это очень хороший специалист:
    
    m: сопоставление по нескольким строкам; символы начала и конца (^ и $) начинают работать по нескольким строкам (то есть, происходит сопоставление с началом или концом каждой строки (строки разделяются символами \\n или \\r), а не только с началом или концом всей вводимой строки)
    
    u: обрабатывать шаблон как Unicode липкий; совпадает только с индексом, указанным свойством lastIndex этого регулярного выражения в целевой строке (и не пытается совпадать с любыми более поздними индексами).
    
3.  ### какое будет состояние state, в react компоненте когда мы попробуем его изменить таким образом:
    
    				state = {
    				    count:0
    				}
    
    				this.setState({count: this.state.count + 1});
    				this.setState({count: this.state.count + 1});
    				this.setState({count: this.state.count + 1});
    				
    
    Правильный ответ:
    
    				{
    					count:1
    				}
    			
    
    Поскольку функция setState в реакте асинхронна, state не изменяется мгновенно, поэтому следующий вызов setState получает старое состояние, равное 0. В итоге каждый раз состоянию count будет присваиваться 0 + 1, т.е. единица. для того что бы правильно отработать эту операцию и получить 3, ее нужно обрабатывать через callback функции
    
    				this.setState({ count: this.state.count + 1 }, () => {
    				   this.setState({ count: this.state.count + 1 }, () => {
    				       this.setState({ count: this.state.count + 1 });
    				   });
    				});
    				
    
    Тогда следующий вызов функции setState гарантированно произойдет после того, как state изменится.
    
4.  ### Что это за конструкция и для чего она нужна в react:
    
    				<>
    					{
    					   //...code
    					}
    				</>
    			
    
    Это конструкция позволяет избегать создания в качестве рутового компонента какой то DOM элемент как обертку, а просто сам реакт понимает что содержимого этого тега нужно добавить в родительский компонент.
    

Сложные вопросы:
----------------

1.  ### Что выведется в консоли, и через какое время:
    
    				const promise = new Promise(function(resolve, reject) {
    
    				  setTimeout(function() {
    				  	console.log('Resolve Time');
    				    resolve("OK");
    				  }, 2000);
    
    				  setTimeout(function() {
    				  	console.log('Reject Time');
    				    reject("FAIL!");
    				  }, 1000);
    
    				});
    
    				promise.then(function(result) {
    				  console.log("Result", result);
    				}, function(err) {
    				  console.log("Caught", err);
    				});
    			
    
    Ответ: через секунду выведется 'Reject Time' и сразу же после этого 'Caught FAIL!'. Затем еще спустя одну секунду 'Resolve Time'
    
    Здесь нужно понимать, как работают промисы. У промиса есть два состояния: resolve и reject. Первый используется при успешной работе, второй обычно выводит ошибку, если что-то пошло не так. Код в теле промиса, находящийся за пределами resolve или reject, выполняется в любом случае, поэтому 'Resolve Time' и 'Reject Time' выведется в соответствующие промежутки времени. Результатом промиса будет то состояния, которое наступило первым. Второе, даже если оно наступает через долю секунды, будет проигнорировано (Promise не может передумать). В нашем случае reject наступает первым, поэтому он и будет обрабатываться.
    
2.  ### Каким будет ответ функции:
    
    				function f() {
    				  console.log(this.name);
    				}
    
    				f = f.bind( {name: "Вася"} ).bind( {name: "Петя" } );
    
    				f();
    			
    
    Ответ:
    
    				'Вася'
                
    
    			
    
    Функция bind привязывает контент к выбранной. Это предотвращает такую ошибку, как потеря контента. Сама функция является оберткой над функцией, поэтому второй вызов bind привязывает контент не к нашей функции, а к ее обертке. А так как обертка никак не использует свой контент, то привязка к ней контента ни на что не повлияет. Здесь важен будет только первый вызов функции bind.
    
    		
    
3.  ### Как сделать так, чтобы в объекте нельзя было изменить какое-нибудь свойство?
    
    Ответ: Задать его с помощью метода defineProperty с флагом writable = false
    
    				let obj = {public: 'public value'}
    				Object.defineProperty(obj, 'protected', {value: "protected value", writable: false})
    				obj.protected = 'change';
    				выдаст ошибку;
    			
    
4.  ### В какой последовательности будут выводиться сообщения:
    
    				console.log('start');
    				const intervalId = setInterval(() => {
    				  console.log('setInterval');
    				}, 0);
    
    				setTimeout(() => {
    				  console.log('setTimeout 1'); 
    
    				  const promise = new Promise((resolve, reject) => {
    				    resolve('then 4');
    				  });
    
    				  promise
    				    .then((value) => {
    				      console.log(value); 
    
    				      setTimeout(() => {
    				        console.log('setTimeout 2');
    				        clearInterval(intervalId);
    				      }, 0);
    				    });
    				}, 0);
    
    				const promise = new Promise((resolve, reject) => {
    				  resolve('then 1');
    				});
    
    				promise
    				  .then((value) => {
    				    console.log(value);
    				    return 'then 2';
    				  })
    				  .then((value) => {
    				    console.log(value); 
    
    				    return new Promise((resolve, reject) => {
    				      setTimeout(resolve, 0, 'then 3');
    				    });
    				  })
    				  .then((value) => {
    				    console.log(value); 
    				  });
    				console.log('end');
    			
    
    Ответ:
    
    				start
    				end
    				then 1
    				then 2
    				setInterval
    				setTimeout 1
    				then 4
    				then 3
    				setInterval
    				setTimeout 2
    			
    
    Это очень сложный вопрос на понимание, в какой последовательности обрабатываются различные процессы в JavaScript. Для того, чтобы правильно ответить на вопрос, необходимо знать, что существуют две очереди выполнения процессов. В первую попадают Microtasks, а во вторую Tasks. К разряду Microtasks можно отнести промисы и nextTick. К Tasks - различные таймауты.
    
    Очередь из микрозадач выполняется с приоритетом. А вторая очередь выполняется только тогда, когда в первой ничего для выполнения не осталось. Поехали: Сразу выведятся start, так как это синхронный код. затем во вторую очередь попадает setInterval, следом туда же идет setTimeout. И в первую очередь проходит promise. Дальше следует end, и он сразу же выводится. Получаем: **start end В первой очереди: promise(then 1) Во второй очереди: setInterval, setTimeout(setTimeout 1)**
    
    Дальше выполняется первая очередь: выводится 'then 1', и в первую очередь ставится еще один promise(then 2). И он сразу же выполняется, выводя в консоль 'then 2', и опять же ставит в первую очередь промис(then 3). Результатом выполнения этого промиса является функция setTimeout, которая должна будет вывести then 3, когда придет ее очередь. Она становится в конец первой очереди.
    
    В итоге: **start end then 1 then 2 В первой очереди: Во второй очереди: setInterval, setTimeout(setTimeout 1), setTimeout(then 3)**
    
    Так как в первой очереди задач не осталось, выполняется вторая очередь. В результате действия setInterval, в консоль выводится 'setInterval', а интервал уходит в конец второй очереди. Дальше, в первой очереди попрежнему ничего нет, продолжается выполнение первой очереди. Срабатывает setTimeout(setTimeout 1). В консоль выводится 'setTimeout 1', и в первую очередь залетает promise('then 4'). В итоге: **start end then 1 then 2 setInterval setTimeout 1 then 4 then 3 setInterval В первой очереди: Во второй очереди: setTimeout(then 3), setInterval**
    
    Так как в первой очереди появилась задача, выполняется она. В консоль выводится 'then 4' и в конец второй очереди ставится setTimeout(setTimeout 2). После этого в первой очереди нет ничего, продолжается выполнение второй очереди, то есть отрабатывает setInterval. Он кидает в консоль 'setInterval', и ставит его снова в конец второй очереди. В итоге: **start end then 1 then 2 setInterval setTimeout 1 then 4 then 3 setInterval В первой очереди: Во второй очереди: setTimeout(setTimeout 2), setInterval**
    
    В результате выполнения setTimeout(setTimeout 2) в консоль выводится 'setTimeout 2', а из первой очереди уберается setInterval. И в итоге получается: **start end then 1 then 2 setInterval setTimeout 1 then 4 then 3 setInterval setTimeout 2 В первой очереди: Во второй очереди:**
    
    Ни в первой, ни во второй очередях не осталось задач, процесс завершается.
    
5.  ### Сколько бит занимает любое число в JS:
    
    Ответ:
    
    				64 бита
                
    
    Любое число занимает 64 бита, важно понимать сколько памяти потребляет написаное приложение и как оно может масштабироваться. Мы можем написать к примеру большой массив данных и там будут просто числа, и каждое число будет потреблять память. Если кандидат вспомнит про IEEE 754 стандарт то это достаточно высокий уровень познания.
